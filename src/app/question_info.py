
questions = {
1:{
    "id" : 1,
    "title" : "리스트의 합 구하기",
    "question_content" : "Parameter로 주어진 리스트에 있는 모든 숫자의 합을 반환하세요",
    "question_example_one_test" : "[1,2,3]",
    "question_example_one_answer" : "6",
    "question_example_one_explanation" : "1+2+3 = 6",
    "question_example_two_test" : "[4,4,4]",
    "question_example_two_answer" : "12",
    "question_example_two_explanation" : "4+4+4 = 12",
    "question_scaffold" : "class Solution:\n    def listSum(self, lst: List[int]) -> int:\n",
    "question_tag": "Array"
},
2: {
    "id" : 2,
    "title" : "유효한 괄호",
    "question_content" : "'(, ')', '{', '}, '[' 및 '] 문자만 포함된 문자열이 주어지면 입력 문자열이 유효한지 확인합니다.\n\n입력 문자열은 다음과 같은 경우에 유효합니다:\n- 열린 브래킷은 동일한 유형의 브래킷으로 닫아야 합니다.\n- 열린 브래킷은 올바른 순서로 닫아야 합니다.\n- 모든 클로즈 브래킷에는 동일한 유형의 오픈 브래킷이 있습니다.\n",
    "question_example_one_test" : "s = '()[]{}'",
    "question_example_one_answer" : "True",
    "question_example_one_explanation" : "(),[],{} 모든 브래킷이 열고 닫힙니다",
    "question_example_two_test" : "s = '(]'",
    "question_example_two_answer" : "False",
    "question_example_two_explanation" : "같은 브래킷 유형이 아닙니다",
    "question_scaffold" : "class Solution:\n    def validParentheses(self, s: str) -> bool:\n",
    "question_tag": "Stack"

},
3:{
    "id" : 3,
    "title" : "매매 대회",
    "question_content" : "가격[i]가 주어진 주식의 배열이 주어집니다. \n주식을 매수할 날을 선택하고 해당 주식을 팔 다른 날을 선택하여 이익을 극대화하려고 합니다. 거래는 한번만 할 수 있습니다. \n이 거래를 통해 얻을 수 있는 최대 이익을 반환하십시오. 수익을 낼 수 없는 경우 0을 반환합니다.",
    "question_example_one_test" : "prices = [7,1,5,3,6,4]",
    "question_example_one_answer" : "5",
    "question_example_one_explanation" : "2번째 날(가격=1)에 매수, 5번째 날(가격=6)에 매도. 6-1 = 5 가 최대 수익입니다.",
    "question_example_two_test" : "prices = [7,6,4,3,1]",
    "question_example_two_answer" : "0",
    "question_example_two_explanation" : "가격이 내려가기만 하기 때문에 매수를 하지 않습니다. 0을 반환합니다.",
    "question_scaffold" : "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n",
    "question_tag": "Sliding Window"
},
4:{
    "id" : 4,
    "title" : "점프",
    "question_content" : "정수 배열이 주어집니다. 배열의 첫 번째 인덱스에서 시작해서, 인덱스에 있는 정수만큼 최대 점프를 할 수 있습니다. \n 마지막 인덱스에 도달할 수 있으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.",
    "question_example_one_test" : "nums = [2,3,1,1,4]",
    "question_example_one_answer" : "True",
    "question_example_one_explanation" : "nums[0], 0번째 인덱스에서는 최대 2만큼 점프 할 수 있습니다. nums[1], nums[2]에 도달 할 수 있습니다. num[1], index 1에 도달 한 뒤, 3 칸을 점프하여 마지막에 도달 가능하기 떄문에 True를 반환합니다.",
    "question_example_two_test" : "nums = [3,2,1,0,4]",
    "question_example_two_answer" : "False",
    "question_example_two_explanation" : "어떤 점프 길이를 선택해도, 마지막 인덱스에 도달 할 수 없기 때문에 False를 반환합니다",
    "question_scaffold" : "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n",
    "question_tag": "Dynamic Programming"
},
5: {
    "id" : 5,
    "title" : "상위 K번 빈도 요소",
    "question_content" : "정수 배열과 정수 k가 주어집니다. \n\n가장 빈도가 높은  k개의 요소를 반환하세요.",
    "question_example_one_test" : "nums = [1,1,1,2,2,3], k = 2",
    "question_example_one_answer" : "[1,2]",
    "question_example_one_explanation" : "배열에서 빈도가 높은 순서는 [1(3개),2(2개),3(1개)] 입니다. k=2 이므로 [1,2] 가 정답입니다",
    "question_example_two_test" : "nums = [1], k = 1",
    "question_example_two_answer" : "[1]",
    "question_example_two_explanation" : "배열에 요소가 하나 뿐입니다. k=1 이므로 [1]을 반환합니다.",
    "question_scaffold" : "class Solution:\n    def topKFrequent(self, nums: List[int], K:int) -> List[int]:\n",
    "question_tag": "Heap"
},
6: {
    "id" : 6,
    "title" : "팰린드롬",
    "question_content" : "주어진 정수가 팰린트롬인지 확인하세요.",
    "question_example_one_test" : "12321",
    "question_example_one_answer" : "True",
    "question_example_one_explanation" : "왼쪽에서 오른쪽으로 읽었을 때는 12321, 오른쪽에서 왼쪽으로 읽었을 때도 12321 입니다.",
    "question_example_two_test" : "-121",
    "question_example_two_answer" : "False",
    "question_example_two_explanation" : "왼쪽에서 오른쪽으로 읽었을 때는 -121, 오른쪽에서 왼쪽으로 읽었을 때는 121- 이기 때문에 팰린드롬이 아닙니다.",
    "question_scaffold" : "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n",
    "question_tag": "Math"
},
7 : {
    "id" : 7,
    "title" : "마지막 단어의 길이",
    "question_content" : "문자와 공백으로 이루어진 문자열에서 마지막 단어의 길이를 반환하세요.",
    "question_example_one_test" : "s=\"Hello World\"",
    "question_example_one_answer" : "5",
    "question_example_one_explanation" : "마지막 단어 World의 길이는 5 입니다.",
    "question_example_two_test" : "s=\"fly me to the mooon \t   \"",
    "question_example_two_answer" : "5",
    "question_example_two_explanation" : "마지막 단어 mooon의 길이는 5 입니다. ",
    "question_scaffold" : "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n",
    "question_tag": "String"
},
8 : {
    "id" : 8,
    "title" : "부분집합",
    "question_content" : "주어진 배열로 만들 수 있는 모든 부분 집합을 배열로 반환하세요.",
    "question_example_one_test" : "nums = [1,2,3]",
    "question_example_one_answer" : "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
    "question_example_one_explanation" : "[1,2,3]으로 만들 수 있는 부분 집합",
    "question_example_two_test" : "nums = [0]",
    "question_example_two_answer" : "[[],[0]]",
    "question_example_two_explanation" : "Empty Array도 포함 되어야 합니다.",
    "question_scaffold" : "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n",
    "question_tag": "DFS"
},
9 : {
    "id" : 9,
    "title" : "도둑",
    "question_content" : "당신은 거리에 있는 집들의 금품을 훔치기 위해 계획하는 강도입니다. 각 집에는 일정 금액의 금품이 있지만, 연이어 붙어 있는 두 집을 같은 밤에 침입하면 경비 시스템이 작동하여 경찰에게 자동으로 연락됩니다.\n\n집들의 금품 금액을 나타내는 정수 배열 nums가 주어지면, 경비 시스템을 작동시키지 않고 밤에 훔칠 수 있는 최대 금액을 반환하세요.",
    "question_example_one_test" : "nums = [1,2,3,1]",
    "question_example_one_answer" : "4",
    "question_example_one_explanation" : "0번째 집과 2번째 집에 들어가서 1+3 = 4 금액의 금품을 훔칠 수 있습니다.",
    "question_example_two_test" : "nums = [2,7,9,3,1]",
    "question_example_two_answer" : "12",
    "question_example_two_explanation" : "0,2,4 번째 집에 들어가서 2+9+1 = 12 금액의 금품을 훔칠 수 있습니다.",
    "question_scaffold" : "class Solution:\n    def rob(self, nums: List[int]) -> int:\n",
    "question_tag": "Dynamic Programming"
},
10 : {
    "id" : 10,
    "title" : "섬",
    "question_content" : "땅('1')과 물('0')로 이루어진 지도를 나타내는 이중 배열 그리드가 주어졌을 때, 물로 둘러싸인 섬의 개수를 반환하세요.\n\n섬은 물로 둘러싸여 있으며, 수평 또는 수직으로 인접한 땅을 연결하여 형성됩니다. 전체 그리드는 물로 둘러싸여 있다고 가정합니다.",
    "question_example_one_test" : "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
    "question_example_one_answer" : "1",
    "question_example_one_explanation" : "1개의 섬이 존재합니다.",
    "question_example_two_test" : "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
    "question_example_two_answer" : "3",
    "question_example_two_explanation" : "3개의 섬이 존재합니다. 섬은 모서리로 연결 될 수 없습니다 않습니다. 지도의 (2,2) 는 하나의 섬입니다",
    "question_scaffold" : "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int\n",
    "question_tag": "BFS"
},
11 : {
    "id" : 11,
    "title" : "Anagram",
    "question_content" : "두 개의 문자열 s와 t가 주어졌을 때, t가 s의 Anagram인 경우 true를 반환하고, 그렇지 않으면 false를 반환하세요.\nAnagram 여부는  's의 모든 문자를 정확히 한 번 사용하고 문자들을 재배열해서 t를 만들 수 있는가?' 를 통해 확인합니다.",
    "question_example_one_test" : "s = 'anagram', t = 'nagaram'",
    "question_example_one_answer" : "True",
    "question_example_one_explanation" : "문자열 s에서 a 와 n 의 순서를 바꾸면 t를 만들 수 있습니다.",
    "question_example_two_test" : "s = 'rat', t = 'car'",
    "question_example_two_answer" : "False",
    "question_example_two_explanation" : "문자열 s와 t에 다른 문자가 있습니다. Anagram이 될 수 없습니다.",
    "question_scaffold" : "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n",
    "question_tag": "Hash Table"
},
12 : {
    "id" : 12,
    "title" : "없어진 숫자",
    "question_content" : "[0, n] 범위 내의 n개의 고유한 수를 포함하는 배열 nums가 주어졌을 때, 배열에서 누락된 숫자 하나를 반환하세요.",
    "question_example_one_test" : "nums = [1,0,3]",
    "question_example_one_answer" : "2",
    "question_example_one_explanation" : "0~3에서 누락된 숫자는 2 입니다.",
    "question_example_two_test" : "nums = [0,1]",
    "question_example_two_answer" : "2",
    "question_example_two_explanation" : "E0~2에서 누락된 숫자는 2 입니다.",
    "question_scaffold" : "class Solution:\n    def missingNumber(self, nums: List[int]) -> List[List[int]]:\n",
    "question_tag": "Array"
},
13: {
    "id" : 13,
    "title" : "겹치는 구간",
    "question_content" : "배열 intervals이 주어졌을 때, intervals[i] = [starti, endi]는 i번째 구간의 시작과 끝을 나타냅니다. 남은 구간들이 서로 겹치지 않도록 하기 위해 제거해야 하는 최소한의 interval 수를 반환하세요.",
    "question_example_one_test" : "intervals = [[1,2],[2,3],[3,4],[1,3]]",
    "question_example_one_answer" : "1",
    "question_example_one_explanation" : "구간 [1,3]을 제거하면 모든 구간들이 겹치지 않습니다.",
    "question_example_two_test" : "intervals = [[1,2],[1,2],[1,2]]",
    "question_example_two_answer" : "2",
    "question_example_two_explanation" : "[1,2]구간 두개를 제거해야 모든 구간들이 겹치지 않습니다.",
    "question_scaffold" : "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n",
    "question_tag": "Sorting, Dynamic Programming"
}, 
14 : {
    "id" : 14,
    "title" : "배열 제곱",
    "question_content" : "오름차순으로 정렬된 정수 배열 nums가 주어졌을 때, 각 숫자의 제곱값을 오름차순으로 정렬한 배열을 반환하세요.",
    "question_example_one_test" : "nums = [-4,-1,0,3,10]",
    "question_example_one_answer" : "[0,1,9,16,100]",
    "question_example_one_explanation" : "모든 수를 제곱하면 [16,1,0,9,100]이 됩니다. 이를 정렬하면 [0,1,9,16,100]이 됩니다.",
    "question_example_two_test" : "nums = [-7,-3,2,3,11]",
    "question_example_two_answer" : "[4,9,9,49,121]",
    "question_example_two_explanation" : "모든 수를 제곱하면 [49,9,4,9,121]이 됩니다. 이를 정렬하면 [4,9,9,49,121]이 됩니다.",
    "question_scaffold" : "class Solution:\n    def sortedSquares(self, nums: List[int]) -> List[int]:\n",
    "question_tag": "Array"
},
15 : {
    "id" : 15,
    "title" : "단계별 줄이기",
    "question_content" : "정수 num이 주어졌을 때, num이 0이 될 때까지 줄일 때 필요한 단계 수를 반환하세요. 정수를 줄이는 단계는 다음 과 같이 이루어집니다: 숫자가 짝수이면 2로 나누고, 홀수이면 1을 뺍니다.",
    "question_example_one_test" : "num = 14",
    "question_example_one_answer" : "6",
    "question_example_one_explanation" : "\n  단계 1) 14 는 짝수; 2 로 나누면 7.\n  단계 2) 7 은 홀수; 1 을 빼면 6.\n  단계 3) 6 은 짝수; 2 로 나누면 3.\n  단계 4) 3 은 홀수; 1 을 빼면 2.\n  단계 5) 2 은 짝수; 2 로 나누면 1.\n  단계 6) 1 은 홀수; 1 을 빼면 0.",
    "question_example_two_test" : "num = 8",
    "question_example_two_answer" : "4",
    "question_example_two_explanation" : "\n  단계 1) 8 는 짝수; 2 로 나누면 4.\n  단계 2) 4 는 짝수; 2 로 나누면 2.\n  단계 3) 2 는 짝수; 2 로 나누면 1.\n  단계 4) 1 는 홀수; 1 을 뼈면 0.",
    "question_scaffold" : "class Solution:\n    def numberOfSteps(self, num: int) -> int:\n",
    "question_tag": "Bit Manipulation"
},
16 : {
    "id" : 16,
    "title" : "파스칼의 삼각형",
    "question_content" : "당신은 거리에 있는 집들의 금품을 훔치기 위해 계획하는 강도입니다. 각 집에는 일정 금액의 금품이 있지만, 연이어 붙어 있는 두 집을 같은 밤에 침입하면 경비 시스템이 작동하여 경찰에게 자동으로 연락됩니다.\n\n집들의 금품 금액을 나타내는 정수 배열 nums가 주어지면, 경비 시스템을 작동시키지 않고 밤에 훔칠 수 있는 최대 금액을 반환하세요.",
    "question_example_one_test" : "numRows = 5",
    "question_example_one_answer" : "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
    "question_example_one_explanation" : "[1,1] = [1+1,1+1] , [1,2,1] = [1, 1+1, 1] [1,3,3,1] = [1, 1+2, 1+2, 1]...",
    "question_example_two_test" : "Input: numRows = 1",
    "question_example_two_answer" : "[[1]]",
    "question_example_two_explanation" : "파스칼 삼각형의 Base Case",
    "question_scaffold" : "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n",
    "question_tag": "Dynamic Programming"
},
17: {
    "id" : 17,
    "title" : "이진탐색",
    "question_content" : "오름차순으로 정렬된 정수 배열(nums)과 정수(target)가 주어졌을 때, target이 nums에 존재하면 해당 인덱스를 반환하고, 존재하지 않으면 -1을 반환하는 함수를 작성하세요. \n 함수는 O(log n) 시간 복잡도에 실행 되어야 합니다.",
    "question_example_one_test" : "nums = [-1,0,3,5,9,12], target = 9",
    "question_example_one_answer" : "4",
    "question_example_one_explanation" : "9가 nums[4]에 있으므로 4를 반환합니다.",
    "question_example_two_test" : "nums = [-1,0,3,5,9,12], target = 2",
    "question_example_two_answer" : "-1",
    "question_example_two_explanation" : "2가 nums에 없으므로 -1을 반환합니다.",
    "question_scaffold" : "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n",
    "question_tag": "Binary Search"
}
}